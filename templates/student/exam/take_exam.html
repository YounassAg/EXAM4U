{% extends 'base.html' %}
{% load static %}
{% block extra_css %}
{% include 'components/code_editor_deps.html' %}
<!-- SweetAlert2 CSS -->
<link rel="stylesheet" href="{% static 'js/vendor/sweetalert2.min.css' %}">
<style>
    /* Code editor specific styles */
    .code-question-wrapper {
        margin-top: 1rem;
    }

    .language-selector {
        margin-bottom: 0.5rem;
        min-width: 150px;
    }

    /* Attachment container styles */
    .attachment-item {
        display: flex;
        flex-direction: column;
        max-width: 100%;
        height: auto;
    }

    .attachment-preview-container {
        position: relative;
        width: 100%;
        max-height: 350px;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: rgba(0, 0, 0, 0.03);
        border-radius: 0.5rem;
    }

    .attachment-preview-container img,
    .attachment-preview-container video {
        max-width: 100%;
        max-height: 350px;
        width: auto;
        height: auto;
        object-fit: contain;
    }

    .attachment-preview-container object {
        width: 100%;
        height: 350px;
    }

    .document-preview {
        width: 100%;
        max-height: 350px;
        overflow: hidden;
    }

    .document-icon-container {
        height: 200px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background-color: rgba(0, 0, 0, 0.03);
        border-radius: 0.5rem;
    }

    /* Dark mode adjustments */
    .dark .attachment-preview-container {
        background-color: rgba(255, 255, 255, 0.03);
    }

    .dark .document-icon-container {
        background-color: rgba(255, 255, 255, 0.03);
    }

    /* Ensure code editor is visible in both light and dark modes */
    .CodeMirror {
        height: 200px !important;
        font-size: 14px;
        line-height: 1.6;
        border-radius: 0.5rem;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .dark .CodeMirror {
        border-color: rgb(75 85 99 / 0.5);
    }

    .CodeMirror-focused {
        border-color: #3b82f6 !important;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5) !important;
    }

    .CodeMirror-placeholder {
        color: #9ca3af !important;
    }

    .dark .CodeMirror-placeholder {
        color: #6b7280 !important;
    }

    .CodeMirror-linenumber {
        color: #6b7280;
        padding: 0 8px;
    }

    .dark .CodeMirror-linenumber {
        color: #9ca3af;
    }

    .CodeMirror-gutters {
        border-right: 1px solid #e5e7eb;
        background-color: #f9fafb;
    }

    .dark .CodeMirror-gutters {
        border-right: 1px solid #374151;
        background-color: #1f2937;
    }

    /* Scrollbar styling */
    .CodeMirror-vscrollbar,
    .CodeMirror-hscrollbar {
        outline: none;
    }

    .CodeMirror-scrollbar-filler {
        background-color: transparent;
    }

    /* Selection color */
    .CodeMirror-selected {
        background: #e5e7eb !important;
    }

    .dark .CodeMirror-selected {
        background: #374151 !important;
    }

    /* Active line highlight */
    .CodeMirror-activeline-background {
        background: #f3f4f6;
    }

    .dark .CodeMirror-activeline-background {
        background: #1f2937;
    }

    /* Modal styles */
    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        z-index: 1000;
        backdrop-filter: blur(5px);
    }

    .modal-content {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        height: 90%;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        background: rgba(0, 0, 0, 0.02);
        border-radius: 12px;
    }

    .modal-content img {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        transform-origin: center;
        transition: transform 0.3s ease;
    }

    .modal-content object {
        width: 100%;
        height: 100%;
        transform-origin: center;
        transition: transform 0.3s ease;
    }

    .modal-content .document-wrapper {
        width: 100%;
        height: 100%;
        overflow: auto;
        display: flex;
        align-items: flex-start;
        justify-content: center;
        cursor: grab;
    }

    .modal-content .document-wrapper:active {
        cursor: grabbing;
    }

    .modal-content .document-wrapper.zoomed {
        overflow: hidden;
    }

    .zoom-controls {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
        background: rgba(0, 0, 0, 0.7);
        padding: 12px;
        border-radius: 12px;
        backdrop-filter: blur(10px);
        z-index: 1001;
        transition: opacity 0.3s ease, transform 0.3s ease;
        opacity: 0.6;
    }

    .zoom-controls:hover {
        opacity: 1;
        transform: translateY(0);
    }

    .zoom-btn {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        color: white;
        padding: 8px 16px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.3s ease;
        min-width: 44px;
        text-align: center;
        position: relative;
        overflow: hidden;
    }

    .zoom-btn:hover {
        background: rgba(255, 255, 255, 0.3);
    }

    .zoom-btn::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.1);
        transform: translate(-50%, -50%) scale(0);
        border-radius: 50%;
        transition: transform 0.3s ease;
    }

    .zoom-btn:active::after {
        transform: translate(-50%, -50%) scale(1.5);
    }

    .close-modal {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(255, 255, 255, 0.2);
        border: none;
        color: white;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
    }

    .close-modal:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: rotate(90deg);
    }

    .preview-wrapper {
        cursor: zoom-in;
    }

    /* Add these styles to the existing style section */
    .document-wrapper {
        cursor: grab;
        overflow: hidden;
        width: 100%;
        height: 100%;
        position: relative;
        touch-action: none;
        background: rgba(0, 0, 0, 0.02);
        border-radius: 8px;
    }

    .document-wrapper.dragging {
        cursor: grabbing;
        user-select: none;
    }

    .document-wrapper img,
    .document-wrapper object {
        pointer-events: none;
        transform-origin: 0 0;
        position: relative;
        transition: transform 0.1s cubic-bezier(0.4, 0, 0.2, 1);
        will-change: transform;
    }

    .document-wrapper.dragging img,
    .document-wrapper.dragging object {
        transition: none; /* Disable transition while dragging for responsiveness */
    }

    .document-wrapper.animating img,
    .document-wrapper.animating object {
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .modal-content {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        height: 90%;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        background: rgba(0, 0, 0, 0.02);
        border-radius: 12px;
    }

    /* Dark mode adjustments */
    .dark .document-wrapper {
        background: rgba(255, 255, 255, 0.02);
    }

    .dark .modal-content {
        background: rgba(255, 255, 255, 0.02);
    }

    /* Enhanced zoom controls */
    .zoom-controls {
        opacity: 0.6;
        transition: opacity 0.3s ease, transform 0.3s ease;
        transform: translateY(20px);
    }

    .zoom-controls:hover {
        opacity: 1;
        transform: translateY(0);
    }

    .zoom-btn {
        position: relative;
        overflow: hidden;
    }

    .zoom-btn::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.1);
        transform: translate(-50%, -50%) scale(0);
        border-radius: 50%;
        transition: transform 0.3s ease;
    }

    .zoom-btn:active::after {
        transform: translate(-50%, -50%) scale(1.5);
    }

    /* Add loading state styles */
    .document-wrapper.loading {
        position: relative;
    }

    .document-wrapper.loading::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 40px;
        height: 40px;
        margin: -20px 0 0 -20px;
        border: 3px solid rgba(0, 0, 0, 0.1);
        border-radius: 50%;
        border-top-color: #3b82f6;
        animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }

    .dark .document-wrapper.loading::after {
        border-color: rgba(255, 255, 255, 0.1);
        border-top-color: #60a5fa;
    }

    /* Error state styles */
    .document-wrapper.error {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem;
        text-align: center;
        color: #ef4444;
    }

    .dark .document-wrapper.error {
        color: #f87171;
    }

    /* Add keyboard navigation hint */
    .navigation-hint {
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 8px 16px;
        border-radius: 8px;
        font-size: 14px;
        opacity: 0;
        transition: opacity 0.3s ease;
        pointer-events: none;
        white-space: nowrap;
        backdrop-filter: blur(10px);
    }

    .navigation-hint.visible {
        opacity: 0.8;
    }

    .dark .navigation-hint {
        background: rgba(255, 255, 255, 0.2);
    }
</style>
{% endblock %}
{% block title %}{{ exam.title }} - Exam4U{% endblock %}

{% block content %}
<div class="flex min-h-screen bg-gray-50 dark:bg-gray-900">
    {% include 'components/student_sidebar.html' %}

    <div class="flex-1 p-4 md:p-8">
        <!-- Main Content -->
        <div class="space-y-6 md:space-y-8">
            <!-- Title Section -->
            <div
                class="relative overflow-hidden bg-white/80 dark:bg-gray-800/80 backdrop-blur-lg rounded-2xl shadow-lg border border-gray-200 dark:border-gray-700 hover:shadow-xl hover:border-blue-500 dark:hover:border-blue-500 transition-all duration-300">
                <div
                    class="absolute top-0 right-0 -mt-4 -mr-4 w-32 h-32 bg-gradient-to-br from-blue-500/20 to-purple-500/20 dark:from-blue-400/10 dark:to-purple-400/10 rounded-full blur-3xl animate-pulse">
                </div>
                <div
                    class="absolute bottom-0 left-0 -mb-4 -ml-4 w-32 h-32 bg-gradient-to-tr from-purple-500/20 to-pink-500/20 dark:from-purple-400/10 dark:to-pink-400/10 rounded-full blur-3xl animate-pulse delay-1000">
                </div>
                <div class="relative z-10 p-6 md:p-8">
                    <div class="flex flex-col space-y-4">
                        <div class="flex items-center justify-between flex-wrap gap-4">
                            <h1
                                class="text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 dark:from-blue-400 dark:to-purple-400 bg-clip-text text-transparent">
                                {{ exam.title }}</h1>
                        </div>
                        <p class="text-gray-600 dark:text-gray-400">{{ exam.description }}</p>
                    </div>
                </div>
            </div>

            <!-- After the exam title section -->
            <div class="mt-6">
                {% if exam.attachments.all %}
                <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg border border-gray-200 dark:border-gray-700 p-6">
                    <h3 class="text-lg font-bold text-gray-900 dark:text-white mb-4">Pièces jointes de l'examen</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        {% for attachment in exam.attachments.all %}
                        <div class="attachment-item bg-white dark:bg-gray-700 rounded-xl p-5 border border-gray-200 dark:border-gray-600 shadow-sm hover:shadow-md transition-all duration-300">
                            {% if attachment.is_image %}
                            <div class="aspect-w-16 aspect-h-9 mb-4 preview-wrapper" onclick="openPreview('{{ attachment.file.url }}', 'image')">
                                <img src="{{ attachment.file.url }}" alt="{{ attachment.title }}" 
                                     class="w-full h-auto max-h-[400px] object-contain rounded-lg shadow-sm hover:shadow-md transition-all duration-300">
                            </div>
                            {% elif attachment.is_video %}
                            <div class="aspect-w-16 aspect-h-9 mb-4">
                                <video controls class="w-full max-h-[400px] rounded-lg shadow-sm hover:shadow-md transition-all duration-300">
                                    <source src="{{ attachment.file.url }}" type="video/{{ attachment.get_file_extension }}">
                                    Votre navigateur ne supporte pas la lecture de vidéos.
                                </video>
                            </div>
                            {% else %}
                            <div class="document-preview mb-4">
                                {% if attachment.file.url|lower|slice:"-4:" == ".pdf" %}
                                <div class="bg-gray-50 dark:bg-gray-600 rounded-lg overflow-hidden preview-wrapper" onclick="openPreview('{{ attachment.file.url }}', 'pdf')" style="height: 400px;">
                                    <object data="{{ attachment.file.url }}" type="application/pdf" width="100%" height="400" class="rounded-lg">
                                        <div class="flex items-center justify-center h-full bg-gray-50 dark:bg-gray-600 p-4 text-center">
                                            <p class="text-gray-600 dark:text-gray-300">Ce navigateur ne supporte pas la visualisation des PDF.</p>
                                        </div>
                                    </object>
                                </div>
                                {% elif attachment.file.url|lower|slice:"-4:" == ".doc" or attachment.file.url|lower|slice:"-5:" == ".docx" or attachment.file.url|lower|slice:"-4:" == ".xls" or attachment.file.url|lower|slice:"-5:" == ".xlsx" or attachment.file.url|lower|slice:"-4:" == ".ppt" or attachment.file.url|lower|slice:"-5:" == ".pptx" %}
                                <div class="flex flex-col items-center justify-center h-48 bg-gray-50 dark:bg-gray-600 rounded-lg p-4 text-center">
                                    <svg class="w-12 h-12 text-gray-400 dark:text-gray-300 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path>
                                    </svg>
                                    <p class="text-sm text-gray-600 dark:text-gray-300">{{attachment.file.name}}</p>
                                </div>
                                {% else %}
                                <div class="flex flex-col items-center justify-center h-48 bg-gray-50 dark:bg-gray-600 rounded-lg p-4">
                                    <svg class="w-12 h-12 text-gray-400 dark:text-gray-300 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path>
                                    </svg>
                                    <p class="text-sm text-gray-600 dark:text-gray-300">{{attachment.file.name}}</p>
                                </div>
                                {% endif %}
                            </div>
                            {% endif %}
                            
                            <div class="flex flex-col">
                                {% if attachment.title %}
                                <h4 class="text-md font-medium text-gray-900 dark:text-white mb-2">{{ attachment.title }}</h4>
                                {% endif %}
                                {% if attachment.description %}
                                <p class="text-sm text-gray-600 dark:text-gray-400">{{ attachment.description }}</p>
                                {% endif %}
                            </div>
                        </div>
                        {% endfor %}
                    </div>
                </div>
                {% endif %}
            </div>

            <!-- Questions Form -->
            <form id="examForm" method="post" onsubmit="confirmSubmit(event)" data-attempt-id="{{ attempt.id }}" class="space-y-6 md:space-y-8">
                {% csrf_token %}
                {% for question in questions %}
                <div
                    class="bg-white dark:bg-gray-800 rounded-xl shadow-lg border border-gray-200 dark:border-gray-700 p-6 space-y-4">
                    <!-- Question Header -->
                    <div class="flex items-center space-x-3">
                        <h3 class="text-lg font-bold text-gray-900 dark:text-white">Question {{ forloop.counter }}</h3>
                        <span class="text-sm text-gray-600 dark:text-gray-400">({{ question.points }} points)</span>
                    </div>

                    <!-- Question Text -->
                    <div
                        class="bg-gray-50/80 dark:bg-gray-700/50 backdrop-blur-sm rounded-xl p-4 border border-gray-200 dark:border-gray-600">
                        <pre
                            class="whitespace-pre-wrap break-words text-gray-700 dark:text-gray-300">{{ question.wording }}</pre>
                    </div>

                    <!-- In the question section, after the question text -->
                    {% if question.attachments.all %}
                    <div class="mt-4">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            {% for attachment in question.attachments.all %}
                            <div class="attachment-item bg-white dark:bg-gray-700 rounded-xl p-5 border border-gray-200 dark:border-gray-600 shadow-sm hover:shadow-md transition-all duration-300">
                                {% if attachment.is_image %}
                                <div class="attachment-preview-container mb-4 preview-wrapper" onclick="openPreview('{{ attachment.file.url }}', 'image')">
                                    <img src="{{ attachment.file.url }}" alt="{{ attachment.title }}" 
                                         class="rounded-lg shadow-sm hover:shadow-md transition-all duration-300">
                                </div>
                                {% elif attachment.is_video %}
                                <div class="attachment-preview-container mb-4">
                                    <video controls class="rounded-lg shadow-sm hover:shadow-md transition-all duration-300">
                                        <source src="{{ attachment.file.url }}" type="video/{{ attachment.get_file_extension }}">
                                        Votre navigateur ne supporte pas la lecture de vidéos.
                                    </video>
                                </div>
                                {% else %}
                                <div class="document-preview mb-4">
                                    {% if attachment.file.url|lower|slice:"-4:" == ".pdf" %}
                                    <div class="attachment-preview-container preview-wrapper" onclick="openPreview('{{ attachment.file.url }}', 'pdf')">
                                        <object data="{{ attachment.file.url }}" type="application/pdf" class="rounded-lg">
                                            <div class="flex items-center justify-center h-full bg-gray-50 dark:bg-gray-600 p-4 text-center">
                                                <p class="text-gray-600 dark:text-gray-300">Ce navigateur ne supporte pas la visualisation des PDF.</p>
                                            </div>
                                        </object>
                                    </div>
                                    {% else %}
                                    <div class="document-icon-container">
                                        <svg class="w-12 h-12 text-gray-400 dark:text-gray-300 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path>
                                        </svg>
                                        <p class="text-sm text-gray-600 dark:text-gray-300">{{attachment.file.name}}</p>
                                    </div>
                                    {% endif %}
                                </div>
                                {% endif %}
                                
                                <div class="flex flex-col mt-2">
                                    {% if attachment.title %}
                                    <h4 class="text-md font-medium text-gray-900 dark:text-white mb-2">{{ attachment.title }}</h4>
                                    {% endif %}
                                    {% if attachment.description %}
                                    <p class="text-sm text-gray-600 dark:text-gray-400">{{ attachment.description }}</p>
                                    {% endif %}
                                </div>
                            </div>
                            {% endfor %}
                        </div>
                    </div>
                    {% endif %}

                    <!-- Choices or Answer Field -->
                    <div class="space-y-3 mt-4">
                        {% if question.question_type == 'MCQ' %}
                        {% for choice in question.mcqchoice_set.all %}
                        {% if question.allow_multiple_answers %}
                        <label
                            class="flex items-start p-4 rounded-lg bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 cursor-pointer hover:bg-blue-50 dark:hover:bg-gray-600">
                            <div class="flex items-center h-5">
                                <input type="checkbox" name="question_{{ question.id }}" value="{{ choice.id }}"
                                    class="w-4 h-4 text-blue-600 border-gray-300 dark:border-gray-600 rounded focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400">
                            </div>
                            <div class="ml-3 flex-1 min-w-0">
                                <span class="text-gray-900 dark:text-white">{{ choice.choice_label }}</span>
                            </div>
                        </label>
                        {% else %}
                        <label
                            class="flex items-start p-4 rounded-lg bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 cursor-pointer hover:bg-blue-50 dark:hover:bg-gray-600">
                            <div class="flex items-center h-5">
                                <input type="radio" name="question_{{ question.id }}" value="{{ choice.id }}"
                                    class="w-4 h-4 text-blue-600 border-gray-300 dark:border-gray-600 focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400"
                                    required>
                            </div>
                            <div class="ml-3 flex-1 min-w-0">
                                <span class="text-gray-900 dark:text-white">{{ choice.choice_label }}</span>
                            </div>
                        </label>
                        {% endif %}
                        {% endfor %}
                        {% elif question.question_type == 'short_answer' %}
                        <div>
                            <input type="text" name="question_{{ question.id }}"
                                class="w-full px-4 py-2 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                required>
                        </div>
                        {% elif question.question_type == 'open' %}
                        {% include 'components/code_question.html' with question_name=question.id %}
                        {% endif %}

                    </div>
                </div>
                {% endfor %}

                <!-- Action Buttons -->
                <div class="mt-8 flex flex-col sm:flex-row justify-end gap-4">
                    <a href="{% url 'student_exam_list' %}" 
                       class="w-full sm:w-auto group inline-flex items-center justify-center px-6 py-3 text-gray-600 dark:text-gray-400 bg-transparent rounded-lg transition-all duration-300 hover:shadow-[0_0_15px_rgba(75,85,99,0.25)] hover:-translate-y-0.5 space-x-2">
                        <div class="p-2 rounded-lg bg-gradient-to-br from-gray-500/10 to-gray-600/10 dark:from-gray-400/5 dark:to-gray-500/5">
                            {% include 'components/icons.html' with icon="x" class="w-5 h-5" %}
                        </div>
                        <span class="font-medium">Annuler</span>
                    </a>
                    <button type="submit"
                            class="w-full sm:w-auto group inline-flex items-center justify-center px-6 py-3 text-blue-600 dark:text-blue-400 bg-transparent rounded-lg transition-all duration-300 hover:shadow-[0_0_15px_rgba(37,99,235,0.25)] hover:-translate-y-0.5 space-x-2">
                        <div class="p-2 rounded-lg bg-gradient-to-br from-blue-500/10 to-purple-500/10 dark:from-blue-400/5 dark:to-purple-400/5">
                            {% include 'components/icons.html' with icon="check" class="w-5 h-5" %}
                        </div>
                        <span class="font-medium">Soumettre l'examen</span>
                    </button>
                </div>
            </form>
        </div>
    </div>
</div>

<style>
    @keyframes pulse {

        0%,
        100% {
            opacity: 0.6;
        }

        50% {
            opacity: 1;
        }
    }

    .animate-pulse {
        animation: pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }

    .delay-1000 {
        animation-delay: 1s;
    }

    @keyframes shake {

        0%,
        100% {
            transform: translateX(0);
        }

        10%,
        30%,
        50%,
        70%,
        90% {
            transform: translateX(-2px);
        }

        20%,
        40%,
        60%,
        80% {
            transform: translateX(2px);
        }
    }

    .shake {
        animation: shake 0.5s cubic-bezier(.36, .07, .19, .97) both;
    }

    /* Input focus styles */
    .focus-within\:ring-2:focus-within {
        --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
        --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
        box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
    }

    /* Smooth transitions */
    .transition-all {
        transition-property: all;
        transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        transition-duration: 300ms;
    }

    /* Choice hover effects */
    .group\/choice:hover {
        --tw-border-opacity: 1;
        border-color: rgb(59 130 246 / var(--tw-border-opacity));
    }

    /* Dark mode specific styles */
    @media (prefers-color-scheme: dark) {
        .group\/choice:hover {
            --tw-border-opacity: 1;
            border-color: rgb(96 165 250 / var(--tw-border-opacity));
        }
    }
</style>

<!-- SweetAlert2 JS -->
<script src="{% static 'js/vendor/sweetalert2.min.js' %}"></script>
<script>
    // Disable back button
    window.history.pushState(null, null, window.location.href);
    window.onpopstate = function () {
        window.history.pushState(null, null, window.location.href);
    };

    // Prevent leaving the page
    window.onbeforeunload = function (e) {
        if (!document.getElementById('examForm').hasAttribute('data-submitted')) {
            e.preventDefault();
            e.returnValue = 'Vous avez un examen en cours. Êtes-vous sûr de vouloir quitter ?';
            return e.returnValue;
        }
    };

    // Initialize code editor manager
    document.addEventListener('DOMContentLoaded', function () {
        // Handle theme changes
        const observer = new MutationObserver(mutations => {
            mutations.forEach(mutation => {
                if (mutation.attributeName === 'class') {
                    document.querySelectorAll('.code-editor').forEach(editorDiv => {
                        const editor = ace.edit(editorDiv);
                        if (editor) {
                            editor.setTheme(
                                "ace/theme/monokai"); // Use monokai for both themes
                        }
                    });
                }
            });
        });

        observer.observe(document.documentElement, {
            attributes: true,
            attributeFilter: ['class']
        });
    });

    // Form submission handling
    function confirmSubmit(event) {
        event.preventDefault(); // Prevent default form submission
        const form = document.getElementById('examForm');
        if (!form) return;

        // Handle all question types
        const questions = document.querySelectorAll('.bg-white.dark\\:bg-gray-800');

        questions.forEach(questionDiv => {
            // Handle MCQ questions
            const radioGroup = questionDiv.querySelectorAll('input[type="radio"]');
            if (radioGroup.length > 0) {
                let isAnswered = false;
                radioGroup.forEach(radio => {
                    if (radio.checked) isAnswered = true;
                });
                if (!isAnswered && radioGroup[0]) {
                    radioGroup[0].checked = true;
                }
            }

            // Handle short answer questions
            const shortAnswer = questionDiv.querySelector('input[type="text"]');
            if (shortAnswer && !shortAnswer.value.trim()) {
                shortAnswer.value = "Not answered";
            }

            // Handle code editor questions
            const codeEditor = questionDiv.querySelector('.code-editor');
            if (codeEditor) {
                const editor = ace.edit(codeEditor);
                const textarea = codeEditor.nextElementSibling;
                const content = editor.getValue().trim();

                if (!content) {
                    editor.setValue("Not answered");
                    textarea.value = "Not answered";
                } else {
                    textarea.value = content;
                }
            }
        });

        // Final confirmation
        Swal.fire({
            title: 'Confirmer la soumission',
            text: 'Êtes-vous sûr de vouloir soumettre votre examen ? Cette action est irréversible.',
            icon: 'warning',
            showCancelButton: true,
            confirmButtonText: 'Oui, soumettre',
            cancelButtonText: 'Non, revenir',
            reverseButtons: true
        }).then((result) => {
            if (result.isConfirmed) {
                form.setAttribute('data-submitted', 'true');
                // Use traditional form submission
                form.submit();
            }
        });
    }

    // Attempt status management
    function updateAttemptStatus(status) {
        const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;

        fetch("{% url 'update_attempt_status' %}", {
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    "X-CSRFToken": csrftoken,
                },
                body: new URLSearchParams({
                    attempt_id: "{{ attempt.id }}",
                    status: status
                }),
            })
            .then(response => response.json())
            .then(data => {
                if (!data.success) {
                    console.error(data.message);
                }
            })
            .catch(error => console.error("Error updating attempt status:", error));
    }

    // Fraud detection logging
    const logFraudAction = (action, details = "") => {
        fetch("{% url 'log_action' %}", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "X-CSRFToken": "{{ csrf_token }}",
            },
            body: JSON.stringify({
                attempt_id: "{{ attempt.id }}",
                action: action,
                details: details,
            }),
        });
    };

    // Enhanced network status monitoring
    class NetworkMonitor {
        constructor() {
            this.disconnectionTime = null;
            this.MAX_OFFLINE_TIME = 40000;
            this.setupListeners();
        }

        setupListeners() {
            window.addEventListener('offline', () => this.handleOffline());
            window.addEventListener('online', () => this.handleOnline());
        }

        handleOffline() {
            this.disconnectionTime = Date.now();
            updateAttemptStatus("abandoned");
            logFraudAction("Network disconnect", "Connexion réseau perdue");
        }

        handleOnline() {
            if (this.disconnectionTime) {
                const offlineTime = Date.now() - this.disconnectionTime;

                if (offlineTime > this.MAX_OFFLINE_TIME) {
                    logFraudAction("Extended disconnect", `Hors ligne pendant ${offlineTime}ms`);
                    updateAttemptStatus("in_progress");
                } else {
                    updateAttemptStatus("in_progress");
                    logFraudAction("Network reconnect", `Reconnecté après ${offlineTime}ms`);
                }
            }
        }
    }

    // Exam Security Management
    const ExamSecurity = {
        focusLostCount: 0, // Add counter for focus loss

        // Track mouse position leaving viewport
        setupMouseTracking() {
            document.addEventListener('mouseleave', (e) => {
                if (e.clientY <= 0 || e.clientX <= 0 ||
                    e.clientX >= window.innerWidth || e.clientY >= window.innerHeight) {
                    logFraudAction("Mouse leave", "Le curseur de la souris a quitté la fenêtre");
                }
            });
        },

        // Detect browser developer tools
        //detectDevTools() {
        //    const devToolsCheck = () => {
        //        const widthThreshold = window.outerWidth - window.innerWidth > 160;
        //        const heightThreshold = window.outerHeight - window.innerHeight > 160;
        //
        //        if (widthThreshold || heightThreshold) {
        //            logFraudAction("Dev tools", "Outils développeur potentiellement ouverts");
        //            return true;
        //        }
        //        return false;
        //    };
        //    setInterval(devToolsCheck, 1000);
        //    window.addEventListener('devtoolschange', function (e) {
        //        if (e.detail.open) {
        //            logFraudAction("Dev tools", "Outils développeur ouverts");
        //        }
        //    });
        //},

        // Prevent right-click context menu
        disableContextMenu() {
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                logFraudAction("Context menu", "Clic droit tenté");
            });
        },

        // Track window focus
        trackWindowFocus() {
            window.addEventListener('blur', () => {
                this.focusLostCount++;
                logFraudAction("Focus lost", `Fenêtre perdue de vue ${this.focusLostCount} fois`);
            });
        },

        // Monitor text selection and copying
        setupTextProtection() {
            document.addEventListener('copy', (event) => {
                logFraudAction("Copy attempt", "Texte copié.");
                // event.preventDefault();
            });

            document.addEventListener('selectstart', (e) => {
                // e.preventDefault();
                logFraudAction("Text selection", "Tentative de sélection de texte");
            });
        },

        // Monitor suspicious shortcuts and screen resizing
        setupKeyboardAndScreenMonitoring() {
            let initialWidth = window.innerWidth;
            let initialHeight = window.innerHeight;

            window.addEventListener("resize", () => {
                const widthDiff = Math.abs(window.innerWidth - initialWidth);
                const heightDiff = Math.abs(window.innerHeight - initialHeight);

                if (widthDiff > 100 || heightDiff > 100) {
                    logFraudAction("Screen resize",
                        `Écran redimensionné: ${window.innerWidth}x${window.innerHeight}`);
                }

                initialWidth = window.innerWidth;
                initialHeight = window.innerHeight;
            });

            document.addEventListener("keydown", (event) => {
                const forbiddenShortcuts = ["c", "v", "a", "s", "p", "u"];
                const isCtrlPressed = event.ctrlKey || event.metaKey;

                if (isCtrlPressed && forbiddenShortcuts.includes(event.key.toLowerCase())) {
                    logFraudAction("Suspicious shortcut",
                        `Raccourci utilisé: Ctrl+${event.key.toUpperCase()}`);
                    // event.preventDefault();
                }
            });
        },

        // Initialize all security measures
        init() {
            this.setupMouseTracking();
            // this.detectDevTools();
            this.disableContextMenu();
            this.trackWindowFocus();
            this.setupTextProtection();
            this.setupKeyboardAndScreenMonitoring();
        }
    };

    // Keep-alive ping
    setInterval(() => {
        if (navigator.onLine) {
            updateAttemptStatus("in_progress");
        }
    }, 30000);

    document.addEventListener('DOMContentLoaded', () => {
        ExamSecurity.init();
        new NetworkMonitor();
    });
</script>
<script>
    // Function to save answers automatically
function saveAnswer(questionId, value, type) {
    const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;
    const attemptId = document.querySelector('#examForm').getAttribute('data-attempt-id');

    // Create the request data based on question type
    let requestData = {
        attempt_id: attemptId,
        question_id: questionId,
        response_text: value || "Not answered"
    };

    if (type === 'MCQ') {
        if (Array.isArray(value)) {
            // For multiple choice questions with multiple answers
            const selectedChoices = value.map(choiceId => {
                const label = document.querySelector(`input[value="${choiceId}"]`)
                    .closest('label')
                    .querySelector('span').textContent.trim();
                return label;
            });
            requestData.response_text = selectedChoices.join(' ~±ſ~ƟƢ~ ');
        } else {
            // For single choice MCQ
            const label = document.querySelector(`input[value="${value}"]`)
                .closest('label')
                .querySelector('span').textContent.trim();
            requestData.response_text = label;
        }
    } else {
        // For text inputs and code editors
        requestData.response_text = value || "Not answered";
    }

    // Make the AJAX request to save the answer
    fetch('/save-answer/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken,
        },
        body: JSON.stringify(requestData)
    })
    .then(response => response.json())
    .then(data => {
        if (!data.success) {
            console.error('Error saving answer:', data.message);
        }
    })
    .catch(error => {
        console.error('Error saving answer:', error);
    });
}

// Setup event listeners for all question types
function setupAnswerTracking() {
    // Handle MCQ inputs
    document.querySelectorAll('input[type="radio"], input[type="checkbox"]').forEach(input => {
        input.addEventListener('change', (e) => {
            const questionId = e.target.name.split('_')[1];
            const type = 'MCQ';
            
            if (e.target.type === 'checkbox') {
                // Get all selected checkboxes for this question
                const selectedValues = Array.from(
                    document.querySelectorAll(`input[name="${e.target.name}"]:checked`)
                ).map(cb => cb.value);
                saveAnswer(questionId, selectedValues, type);
            } else {
                saveAnswer(questionId, e.target.value, type);
            }
        });
    });

    // Handle text inputs
    document.querySelectorAll('input[type="text"]').forEach(input => {
        let timeoutId;
        input.addEventListener('input', (e) => {
            const questionId = e.target.name.split('_')[1];
            
            // Clear existing timeout
            clearTimeout(timeoutId);
            
            // Set new timeout to save after 500ms of no typing
            timeoutId = setTimeout(() => {
                saveAnswer(questionId, e.target.value, 'short_answer');
            }, 500);
        });
    });

    // Handle code editors
    document.querySelectorAll('.code-editor').forEach(editorDiv => {
        const editor = ace.edit(editorDiv);
        const questionId = editorDiv.getAttribute('data-question-id'); // Extract questionId here

        let timeoutId;
        editor.getSession().on('change', () => {
            // Clear existing timeout
            clearTimeout(timeoutId);

            // Set new timeout to save after 1s of no typing
            timeoutId = setTimeout(() => {
                saveAnswer(questionId, editor.getValue(), 'open'); // Use the extracted questionId
            }, 1000);
        });
    });
}

// Load saved answers when page loads or reloads
function loadSavedAnswers() {
    const attemptId = document.querySelector('#examForm').getAttribute('data-attempt-id');
    const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;

    fetch(`/get-saved-answers/${attemptId}/`, {
        headers: {
            'X-CSRFToken': csrftoken,
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            data.answers.forEach(answer => {
                const questionId = answer.question_id;
                const responseText = answer.response_text;

                // Handle MCQ answers
                if (answer.question_type === 'MCQ') {
                    if (responseText.includes(' ~±ſ~ƟƢ~ ')) {
                        // Multiple answers
                        const selectedLabels = responseText.split(' ~±ſ~ƟƢ~ ');
                        selectedLabels.forEach(label => {
                            const input = Array.from(document.querySelectorAll(`input[name="question_${questionId}"]`))
                                .find(input => input.closest('label').querySelector('span').textContent.trim() === label);
                            if (input) input.checked = true;
                        });
                    } else {
                        // Single answer
                        const input = Array.from(document.querySelectorAll(`input[name="question_${questionId}"]`))
                            .find(input => input.closest('label').querySelector('span').textContent.trim() === responseText);
                        if (input) input.checked = true;
                    }
                }
                // Handle text inputs
                else if (answer.question_type === 'short_answer') {
                    const input = document.querySelector(`input[name="question_${questionId}"]`);
                    if (input) input.value = responseText;
                }
                // Handle code editors
                else if (answer.question_type === 'open') {
                    const editorDiv = document.querySelector(`.code-editor[data-question-id="${questionId}"]`);
                    if (editorDiv) {
                        const editor = ace.edit(editorDiv);
                        editor.setValue(responseText, -1);
                    }
                }
            });
        }
    })
    .catch(error => {
        console.error('Error loading saved answers:', error);
    });
}

// Initialize everything when the page loads
document.addEventListener('DOMContentLoaded', () => {
    setupAnswerTracking();
    loadSavedAnswers();
});

// Handle page visibility changes
document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
        loadSavedAnswers();
    }
});
</script>
<script type="text/javascript">
    history.pushState(null, null, location.href);
    window.onpopstate = function () {
        history.go(1);
    };
</script>

<!-- Add this at the end of the body, just before the closing </div> of the main container -->
<!-- Preview Modal -->
<div id="previewModal" class="modal">
    <button class="close-modal" onclick="closePreview()">×</button>
    <div class="modal-content">
        <!-- Content will be dynamically inserted here -->
    </div>
    <div class="zoom-controls">
        <button class="zoom-btn" onclick="zoomOut()">−</button>
        <button class="zoom-btn" onclick="resetZoom()">100%</button>
        <button class="zoom-btn" onclick="zoomIn()">+</button>
    </div>
</div>

<script>
let currentZoom = 1;
const zoomStep = 0.1;
const maxZoom = 5;
const minZoom = 0.5;
let isDragging = false;
let startX, startY;
let translateX = 0;
let translateY = 0;
let lastX, lastY;
let velocityX = 0;
let velocityY = 0;
let lastTime = 0;
let animationFrame = null;
let boundaries = { left: 0, right: 0, top: 0, bottom: 0 };
let pinchStartDistance = 0;
let initialZoom = 1;
let doubleTapTimer = null;
let lastTapTime = 0;
let errorRetries = 0;
const MAX_RETRIES = 3;

function openPreview(url, type) {
    const modal = document.getElementById('previewModal');
    const modalContent = modal.querySelector('.modal-content');
    resetViewState();

    modalContent.innerHTML = '';
    const wrapper = document.createElement('div');
    wrapper.className = 'document-wrapper loading';

    // Add navigation hint
    const hint = document.createElement('div');
    hint.className = 'navigation-hint';
    hint.textContent = 'Use arrow keys to navigate • Double-click to zoom';
    modalContent.appendChild(hint);

    if (type === 'image') {
        const img = document.createElement('img');
        img.src = url;
        img.style.transform = getTransformStyle();
        
        img.onload = function() {
            wrapper.classList.remove('loading');
            setupZoomAndDrag(wrapper, img);
            calculateBoundaries(wrapper, img);
            showNavigationHint();
        };

        img.onerror = function() {
            handleLoadError(wrapper, url, type);
        };

        wrapper.appendChild(img);
    } else if (type === 'pdf') {
        const obj = document.createElement('object');
        obj.data = url;
        obj.type = 'application/pdf';
        obj.style.width = '100%';
        obj.style.height = '100%';
        obj.style.transform = getTransformStyle();
        
        obj.onload = function() {
            wrapper.classList.remove('loading');
            setupZoomAndDrag(wrapper, obj);
            calculateBoundaries(wrapper, obj);
            showNavigationHint();
        };

        obj.onerror = function() {
            handleLoadError(wrapper, url, type);
        };

        wrapper.appendChild(obj);
    }

    modalContent.appendChild(wrapper);
    modal.style.display = 'block';
    document.body.style.overflow = 'hidden';
    document.addEventListener('keydown', handleKeyPress);
}

function resetViewState() {
    currentZoom = 1;
    translateX = 0;
    translateY = 0;
    velocityX = 0;
    velocityY = 0;
    errorRetries = 0;
    cancelAnimationFrame(animationFrame);
}

function handleLoadError(wrapper, url, type) {
    if (errorRetries < MAX_RETRIES) {
        errorRetries++;
        setTimeout(() => {
            const content = wrapper.children[0];
            content.src = url + '?retry=' + Date.now();
        }, 1000 * errorRetries);
    } else {
        wrapper.classList.remove('loading');
        wrapper.classList.add('error');
        wrapper.innerHTML = `
            <div>
                <p>Failed to load ${type}.</p>
                <button onclick="retryLoad('${url}', '${type}')" class="zoom-btn mt-4">
                    Retry
                </button>
            </div>
        `;
    }
}

function retryLoad(url, type) {
    errorRetries = 0;
    openPreview(url, type);
}

function showNavigationHint() {
    const hint = document.querySelector('.navigation-hint');
    hint.classList.add('visible');
    setTimeout(() => {
        hint.classList.remove('visible');
    }, 3000);
}

function setupZoomAndDrag(wrapper, content) {
    wrapper.addEventListener('wheel', (e) => handleZoom(e, wrapper, content), { passive: false });
    wrapper.addEventListener('mousedown', (e) => startDragging(e, wrapper, content));
    wrapper.addEventListener('mousemove', (e) => drag(e, wrapper, content));
    wrapper.addEventListener('mouseup', () => stopDragging(wrapper, content));
    wrapper.addEventListener('mouseleave', () => stopDragging(wrapper, content));
    
    wrapper.addEventListener('mousemove', (e) => {
        lastX = e.clientX;
        lastY = e.clientY;
    });

    // Touch support
    wrapper.addEventListener('touchstart', (e) => handleTouchStart(e, wrapper, content), { passive: false });
    wrapper.addEventListener('touchmove', (e) => handleTouchMove(e, wrapper, content), { passive: false });
    wrapper.addEventListener('touchend', () => stopDragging(wrapper, content));

    // Double-click to zoom
    wrapper.addEventListener('dblclick', (e) => handleDoubleClick(e, wrapper, content));

    // Pinch zoom support
    wrapper.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            e.preventDefault();
            pinchStartDistance = getPinchDistance(e.touches);
            initialZoom = currentZoom;
        }
    }, { passive: false });

    wrapper.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
            e.preventDefault();
            handlePinchZoom(e, wrapper, content);
        }
    }, { passive: false });

    // Single tap detection for mobile
    wrapper.addEventListener('touchend', (e) => {
        const currentTime = Date.now();
        if (currentTime - lastTapTime < 300) {
            // Double tap detected
            e.preventDefault();
            const touch = e.changedTouches[0];
            handleDoubleClick({ clientX: touch.clientX, clientY: touch.clientY }, wrapper, content);
            clearTimeout(doubleTapTimer);
            doubleTapTimer = null;
        } else {
            doubleTapTimer = setTimeout(() => {
                // Single tap actions if needed
            }, 300);
        }
        lastTapTime = currentTime;
    });
}

function handleTouchStart(e, wrapper, content) {
    e.preventDefault();
    const touch = e.touches[0];
    startDragging({ clientX: touch.clientX, clientY: touch.clientY }, wrapper, content);
}

function handleTouchMove(e, wrapper, content) {
    e.preventDefault();
    if (!isDragging) return;
    const touch = e.touches[0];
    drag({ clientX: touch.clientX, clientY: touch.clientY }, wrapper, content);
}

function handleZoom(e, wrapper, content) {
    e.preventDefault();
    
    const rect = wrapper.getBoundingClientRect();
    const mouseX = lastX - rect.left;
    const mouseY = lastY - rect.top;

    const contentX = mouseX - translateX;
    const contentY = mouseY - translateY;

    const delta = e.deltaY < 0 ? 1 : -1;
    const prevZoom = currentZoom;
    currentZoom = Math.max(minZoom, Math.min(maxZoom, currentZoom + (delta * zoomStep)));
    
    if (currentZoom !== prevZoom) {
        translateX = mouseX - (contentX * currentZoom / prevZoom);
        translateY = mouseY - (contentY * currentZoom / prevZoom);
        
        calculateBoundaries(wrapper, content);
        constrainToBoundaries();
        
        content.style.transform = getTransformStyle();
        wrapper.classList.toggle('zoomed', currentZoom > 1);
        updateZoomDisplay();
    }
}

function startDragging(e, wrapper, content) {
    if (e.button !== 0) return;
    cancelAnimationFrame(animationFrame);
    
    isDragging = true;
    startX = e.clientX - translateX;
    startY = e.clientY - translateY;
    lastTime = Date.now();
    velocityX = 0;
    velocityY = 0;
    
    wrapper.classList.add('dragging');
    calculateBoundaries(wrapper, content);
}

function drag(e, wrapper, content) {
    if (!isDragging) return;
    e.preventDefault();
    
    const currentTime = Date.now();
    const deltaTime = currentTime - lastTime;
    const newTranslateX = e.clientX - startX;
    const newTranslateY = e.clientY - startY;
    
    // Calculate velocity
    if (deltaTime > 0) {
        velocityX = (newTranslateX - translateX) / deltaTime;
        velocityY = (newTranslateY - translateY) / deltaTime;
    }
    
    translateX = newTranslateX;
    translateY = newTranslateY;
    
    constrainToBoundaries();
    content.style.transform = getTransformStyle();
    
    lastTime = currentTime;
}

function stopDragging(wrapper, content) {
    if (!isDragging) return;
    isDragging = false;
    wrapper.classList.remove('dragging');
    
    // Apply inertia if there's significant velocity
    if (Math.abs(velocityX) > 0.1 || Math.abs(velocityY) > 0.1) {
        wrapper.classList.add('animating');
        applyInertia(wrapper, content);
    }
}

function applyInertia(wrapper, content) {
    const friction = 0.95;
    const minVelocity = 0.01;

    function animate() {
        velocityX *= friction;
        velocityY *= friction;

        if (Math.abs(velocityX) < minVelocity && Math.abs(velocityY) < minVelocity) {
            cancelAnimationFrame(animationFrame);
            wrapper.classList.remove('animating');
            return;
        }

        translateX += velocityX * 16; // Assuming 60fps (16ms)
        translateY += velocityY * 16;
        
        constrainToBoundaries();
        content.style.transform = getTransformStyle();
        
        animationFrame = requestAnimationFrame(() => animate());
    }

    animate();
}

function constrainToBoundaries() {
    if (currentZoom === 1) {
        translateX = 0;
        translateY = 0;
        return;
    }

    translateX = Math.max(boundaries.left, Math.min(boundaries.right, translateX));
    translateY = Math.max(boundaries.top, Math.min(boundaries.bottom, translateY));
}

function updateZoomDisplay() {
    const zoomPercentage = Math.round(currentZoom * 100);
    const resetZoomBtn = document.querySelector('.zoom-controls button:nth-child(2)');
    if (resetZoomBtn) {
        resetZoomBtn.textContent = `${zoomPercentage}%`;
    }
}

function zoomIn() {
    const wrapper = document.querySelector('.document-wrapper');
    const content = wrapper.children[0];
    if (currentZoom < maxZoom) {
        const prevZoom = currentZoom;
        currentZoom = Math.min(maxZoom, currentZoom + zoomStep);
        
        // Zoom towards center
        const rect = wrapper.getBoundingClientRect();
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        
        translateX = centerX - (centerX - translateX) * currentZoom / prevZoom;
        translateY = centerY - (centerY - translateY) * currentZoom / prevZoom;
        
        content.style.transform = getTransformStyle();
        wrapper.classList.toggle('zoomed', currentZoom > 1);
        updateZoomDisplay();
    }
}

function zoomOut() {
    const wrapper = document.querySelector('.document-wrapper');
    const content = wrapper.children[0];
    if (currentZoom > minZoom) {
        const prevZoom = currentZoom;
        currentZoom = Math.max(minZoom, currentZoom - zoomStep);
        
        // Zoom towards center
        const rect = wrapper.getBoundingClientRect();
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        
        translateX = centerX - (centerX - translateX) * currentZoom / prevZoom;
        translateY = centerY - (centerY - translateY) * currentZoom / prevZoom;
        
        content.style.transform = getTransformStyle();
        wrapper.classList.toggle('zoomed', currentZoom > 1);
        updateZoomDisplay();
    }
}

function resetZoom() {
    const wrapper = document.querySelector('.document-wrapper');
    const content = wrapper.children[0];
    currentZoom = 1;
    translateX = 0;
    translateY = 0;
    content.style.transform = getTransformStyle();
    wrapper.classList.remove('zoomed');
    updateZoomDisplay();
}

function handleKeyPress(e) {
    const wrapper = document.querySelector('.document-wrapper');
    if (!wrapper) return;

    const content = wrapper.children[0];
    const moveStep = 50 / currentZoom;

    switch (e.key) {
        case 'Escape':
            closePreview();
            break;
        case 'ArrowLeft':
            e.preventDefault();
            translateX += moveStep;
            constrainToBoundaries();
            content.style.transform = getTransformStyle();
            break;
        case 'ArrowRight':
            e.preventDefault();
            translateX -= moveStep;
            constrainToBoundaries();
            content.style.transform = getTransformStyle();
            break;
        case 'ArrowUp':
            e.preventDefault();
            translateY += moveStep;
            constrainToBoundaries();
            content.style.transform = getTransformStyle();
            break;
        case 'ArrowDown':
            e.preventDefault();
            translateY -= moveStep;
            constrainToBoundaries();
            content.style.transform = getTransformStyle();
            break;
        case '0':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                resetZoom();
            }
            break;
        case '=':
        case '+':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                zoomIn();
            }
            break;
        case '-':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                zoomOut();
            }
            break;
    }
}

function handleDoubleClick(e, wrapper, content) {
    const rect = wrapper.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    if (currentZoom === 1) {
        // Zoom in to 2x at clicked point
        zoomToPoint(mouseX, mouseY, 2, wrapper, content);
    } else {
        // Reset zoom
        resetZoom();
    }
}

function zoomToPoint(x, y, targetZoom, wrapper, content) {
    const prevZoom = currentZoom;
    currentZoom = targetZoom;

    const contentX = x - translateX;
    const contentY = y - translateY;

    translateX = x - (contentX * currentZoom / prevZoom);
    translateY = y - (contentY * currentZoom / prevZoom);

    calculateBoundaries(wrapper, content);
    constrainToBoundaries();
    
    wrapper.classList.add('animating');
    content.style.transform = getTransformStyle();
    wrapper.classList.toggle('zoomed', currentZoom > 1);
    updateZoomDisplay();

    setTimeout(() => {
        wrapper.classList.remove('animating');
    }, 300);
}

function getPinchDistance(touches) {
    return Math.hypot(
        touches[1].clientX - touches[0].clientX,
        touches[1].clientY - touches[0].clientY
    );
}

function handlePinchZoom(e, wrapper, content) {
    const currentDistance = getPinchDistance(e.touches);
    const scale = currentDistance / pinchStartDistance;
    const newZoom = Math.max(minZoom, Math.min(maxZoom, initialZoom * scale));

    if (newZoom !== currentZoom) {
        // Get the midpoint of the pinch
        const rect = wrapper.getBoundingClientRect();
        const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
        const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;

        zoomToPoint(midX, midY, newZoom, wrapper, content);
    }
}

function closePreview() {
    const modal = document.getElementById('previewModal');
    modal.style.display = 'none';
    document.body.style.overflow = 'auto';
    document.removeEventListener('keydown', handleKeyPress);
}

// Close modal when clicking outside the content
document.getElementById('previewModal').addEventListener('click', function(e) {
    if (e.target === this) {
        closePreview();
    }
});
</script>
{% endblock %}